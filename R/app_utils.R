#
# This script contains all the auxiliary functions necessary to run the shiny 
# app adequately

# Generate empty the template data.frames
empty_dt <- function(type){
  
  if (type == "numeric") {
    mat <- matrix(0, nrow = 8, ncol = 12) %>% 
      data.table::data.table()
    
  } else if (type == "character_std") {
    mock_concs <- c(0, 1, 10, 20, 50, 60, 100, 200)
    std_sample <- paste("std", mock_concs, sep = "_")
    mock_data <- c(std_sample, rep("sample", 96-8))
    
    mat <- matrix(mock_data, nrow = 8, ncol = 12) %>% 
      data.table::data.table()
  } else if (type == "character_blank") {
    mock_data <- c(rep("std", 8),
                   rep("blank", 8), 
                   rep("sample", 96-16))
    
    mat <- matrix(mock_data, nrow = 8, ncol = 12) %>% 
      data.table::data.table()
    
  }  else {
    mat <- matrix("", nrow = 8, ncol = 12) %>% 
      data.table::data.table()
    
  }
  return(mat)
  
}

# Combine the tables in one and make them long format
agg_tables <- function(table_lists, env_vars) {
  
  # Load vars
  layer_name <- env_vars$plate_names
  
  # Generate collection list
  out_long <- vector("list", length = length(layer_name))
  names(out_long) <- layer_name
  
  # Iterate over tables
  n <- 1
  
  for (i in table_lists) {
    
    i[, row := LETTERS[1:8]]
    z <- data.table::melt.data.table(i, id.vars = "row", variable.name = "col")
    z[, col := gsub(pattern = "V", replacement = "", x = col) %>%
        as.numeric()]
    z[, well := paste0(row, col)]
    data.table::setorder(z, row, col, well)
    data.table::setnames(z, "value", layer_name[n])
    out_long[[n]] <- z
    n <- n + 1
  }
  
  merged_table <- Reduce(function (...) { merge(..., all = TRUE) },   # Full join
         out_long)
  
  return(merged_table)
}

# Extrapolate the data in the standard curve
extrapolate_data <- function(long_data) {
  
  # Load variables
  z <- data.table::copy(long_data)
  
  # Correct Abs
  z[, corr_wl := wavelenght1 - wavelenght2]
  z[, backgroud_corr := corr_wl - mean(corr_wl[blank_sample == "blank"])]
  z[backgroud_corr ==0, backgroud_corr := 1]
  z[, log_signal := log10(backgroud_corr * dilution) ]
  
  # Regression model with standard curve
  std_data <- z[standard != "sample"]
  std_data[, c("type","conc") := tstrsplit(standard, "_")]
  std_data[, conc := as.numeric(conc)]
  std_model <- lm(conc ~ log_signal, data = std_data)
  z[, real_conc := predict(std_model, newdata = .SD) %>%
      exp]
  
  return(z)
  
}

# Different useful variables
env_vars <- list(plate_names = c("wavelenght1", "wavelenght2", "dilution", "standard", 
                                 "blank_sample","celltype", "treatments"),
              plate_types = c("wavelenght1" = "numeric", 
                              "wavelenght2" = "numeric",
                              "dilution" = "numeric", 
                              "standard" = "character_std", 
                              "blank_sample" = "character_blank",
                              "celltype" = "character", 
                              "treatments" = "character"),
              text = list(introduction = "
              <br>The purpose of this tool is tostreamline the process of reshaping 
              the output data generated by the ClarioStar. By automating this 
              task, users can save time and reduce the risk of errors.<br>
              
              <br>To use the tool, start by inputting the main absorbance values in 
              the template wavelength1, the secondary absorbance in wavelength2, 
              and the dilution factor. Then, navigate to the 'standard' tab and 
              select which wells contain the standard curve. It is important to 
              use the notation 'std_000' when inputting this information, where 
              000 represents the concentration of the standard at that well.<br>
              
              <br>Next, move to the 'blank_sample' tab and indicate which wells 
              contain the blanks. Finally, use the 'celltype' and 'treatments' 
              tabs to input additional information about the different features of each well.<br>
              
              <br>Once all of the necessary information has been inputted, click on 
              the 'process data' button. The output will be displayed as a table 
              below, showing the reshaped data with the interpolated values. 
              This allows for easy analysis and interpretation of the results.<br>

                          ")
              
              )

